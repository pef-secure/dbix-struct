=head1 NAME

DBIx::Struct - convenience SQL functions with Class::Struct-like row objects

=head1 SYNOPSIS

    use DBIx::Struct;

    DBIx::Struct::connect($data_source, $username, $auth);

    my $row = one_row("table", $idField);

    print $row->field;

    $row->field('new data');

    $row->update;

    my $rows = all_rows("table", {field => "some data"});

    print $rows->[0]->field;

=head1 DESCRIPTION

Makes SQL queries from Perl data structures. It uses L<SQL::Abstract> module to 
parse "where" and "order by" structures. It also supports "group by", "having", 
"limit", "offset" and mapping function. To make actual queries subclass of 
L<DBIx::Connector> is used. The main pupose of this module is to provide a very 
easy, simple and efficient interface to database. Internally every row is just 
an array of values and every accessor knows its offset in that array. This is 
much more efficient as storing row in hash.

=head3 C<connect($data_source, $username, $auth)>

This method connects to database or returns already connected connector object.
For every table in database there's one corresponding class in DBC:: namespaece 
in CamelCase style after successful connect created. E.g. DBC::ClientData is 
created for table "client_data". This namespace is configurable.

=head3 C<one_row($table, $abstract_where, $order_by, $limit, $offset)>

Selects one row from given table and returns its object. $table can be a simple 
table name or returning data query expression. In last case DBQ:: namespace is 
used to name class of row object of such a query.

There are some named paramters can be used together with positional paramaters:

=over

=item -group_by

Generates "GROUP BY" SQL-clause

 my $row1 = one_row("table", -group_by => "field");

Generates and executes "select * from table group by field" SQL-statement. 
 
 my $row2 = one_row("table", -group_by => [qw|field field2|]);
 
Generates and executes "select * from table group by field, field2" SQL-statement.
Returns one row object.

=item -having

Adds "HAVING" conditions to "GROUP BY"
 
 my $row1 = one_row("table", -group_by => "field", -having => {"length(field)" => {">", 5} });

=item -order_by

Generates "ORDER BY" SQL-clause as in L<SQL::Abstract>.

=item -where

Generates "WHERE" SQL-clause as in L<SQL::Abstract>. If $abstract_where is just a scalar
then it is supposed to be a primary key value.

=item -limit

=item -offset

Generates "LIMIT $X OFFSET $Y" SQL-clause.

=back

=head3 C<all_rows($table, $abstract_where, $order_by, $limit, $offset)>

This is just like previous C<one_row> but returns array of row objects. 
It has one more "floating" parameter: you can specify CODE reference in any 
place and it will be used as "mapping function".

    my $rows =  all_rows("table", 
                     { date => {'>=', \"now() - interval '1 hour'"}, 
                     sub {$_->filter_timestamp; $_->data});

This anonymous function is called for every row clearing timestamps from microseconds part 
and converting every row object into anonymous hash.

It's possible to use C<all_rows()> and C<one_row()> not only for simple table 
select but for queries also. 

  my $count = one_row("select count(*) from table", 
                      { date => {'>=', \"now() - interval '1 hour'"})
                      ->count;

  my $name = one_row("select name from client"
                    ."  join session on (id = id_client)", 
                      { session_key => $input->{session}})
                      ->name;

=head3 C<< new_row("table", column => $value, column2 => $value2, ...) >>

Inserts new row into table. Returns row object with set primary columns and passed in 
C<new_row> subroutine. If you need to set all columns from table then:

    my $row = new_row("table", column => $value);
    $row->fetch;

=head2 Row object methods

=head3 C<new>

Creates new row in the table. This is the same as C<new_row()> except table name is already 
known from class name. 

    my $row = DBC::Table->new(email => 'a@bb.com', password => '12345');

=head3 C<set>

Sets values of table columns. Has three forms:

=over

=item C<set([...])>

 Sets internal row data.
 
=item C<< set({column => $value, ... }) >>

 Sets column(s) value(s)
 
=item C<< set(column => $value, ... ) >>

 Same as above but without anonymous hash.
 
=back

This method is useful when you can't use accessors. For example, when you 
have column name 'new' in your table.

=head3 C<data>

Returns values of the row. Has four forms:

=over

=item C<data()>

 No parameters means to return all columns in anonymous hash {column => "value", ... }.

=item C<data([])>

 Empty array reference means internal row data.
 
=item C<data([qw|column columnt2|])>

 Non-empty array means array of values for corresponding columns.
 
=item C<< data({column => undef, columnt2 => undef}) >>

 Returns given columns set in anonymous hash {column => "value", ... }.

=back

=head3 C<update>

Updates its row or table

=over

=item C<update()>

Updates changed (if any) columns of the row.

=item C<< update({column => "value"}, $where) >>

Updates table. For example:

 DBC::List->update({ref => 33}, {id => 1});
 
Means 
 
 update list ref = ?  WHERE ( id = ? )

with bind values 33, 1

=back

=head3 C<delete>

Deletes the row or rows from the table.

=over

=item C<delete()>

Deletes the row if the row has primary key.

=item C<delete($where)>

deletes row(s) from table. For example:

 DBC::List->delete({id => 1});
 
Means 
 
 delete from list WHERE ( id = ? )

with bind value 1

=back

=head3 C<filter_timestamp>

Removes microseconds from timestamp columns. 
 
 2010-05-19 23:30:01.737126 -> 2010-05-19 23:30:01

=head3 C<fetch>

Fetches the whole row data from table. Useful when primary key is known after
insert but other columns are set by database.

=head3 B<Accessors>

All column names from table except special keywords are accessible via accessors:

 my $prim = one_row("prim", 1);
 print "payload: " .  $prim->payload . "\n";
 # new data
 $prim->payload("pay never");
 $prim->update;
 
Here $prim->payload("pay never") sets new column value. To store it explicitly 
call $prim->update. By default update is called on row object destruction. 
To include a random snippet of SQL verbatim, you specify it as a scalar reference.

 $client->bonus(\"bonus + 10");

=head2 Syntax sugar

=head3 Referenced tables

Suppose you have two tables employer and employee:

 employer:
    id_employer,
    name
  
 employee:
    id_employee,
    id_employer references employer (id_employer),
    id_employee_invited_by
    name

 alter table employee add constraint fk_employee_employee 
     foreign key (id_employee_invited_by) references employee (id_employee);

 my $employee = one_row("employee", {name => 'John'});
 my $employer = $employee->Employer;
 
Actually, C<< $employee->Employer >> is just the same as 
C<< one_row("employer", $employee->id_employer) >>.

=head3 Referenced by table

Now you want to find all people invited by one employee:

 my $referenced_by = $employee->refEmployeeInvitedBys;
 
Or only those with name 'Robert':

 my $robert_associates = $employee->Employer->refEmployees(name => 'Robert');

These names "refEmployees", "refEmployee" and alike are made up from:

 "ref" . $TableName . $suffix . $plural
 
C<$plural> is "s" for plural (C<all_rows>) and empty for singular (C<one_row>).
C<$suffix> is used when foreign key column name contains something more then 
just referenced table name and "_id" or "id_". 

C<id_employer> of C<employee> makes methods C<refEmployee> and C<refEmployees> 
in class C<DBC::Employer>. And C<id_employee_invited_by> makes methods
C<refEmployeeInvitedBy> and C<refEmployeeInvitedBys>.

=head2 Real-world usage scenarios 

  sub get_client {
  # get session object
    my $session = one_row("session", {session => $input->{session}, ip => $input->{ip}});
  # throw exception when there's no session
    NoUser->throw("User is not logged in or does not exist") unless defined $session;
  # get client's row
    my $client = $session->Client;
  # strip microseconds part
    $client->filter_timestamp;
  # throw exception if client is blocked
    BlkUser->throw   if $client->state eq 'blocked';
  # set expire date
    $session->expire(\"now() + interval '2 day'");
  # update session
    $session->update;
    return $client;
  }

=head1 Known issues

This module is tested only with PostgreSQL database. If you need other database 
support be prepared to help me to test and debug it.

=head1 See also

=over

=item * L<DBIx::Connector>

=item * L<SQL::Abstract>

=back

=head1 Authors

This module was written and is maintained by:

=over

=item * PEF Developer <pef-secure@yandex.ru>

=back

=cut
