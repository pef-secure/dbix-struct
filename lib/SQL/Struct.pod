=head1 NAME

 SQL::Struct - convenience SQL functions with Class::Struct-like row objects

=head1 SYNOPSIS

    use SQL::Struct;

    SQL::Struct::connect($data_source, $username, $auth);

    my $row = one_row("table", $idField);

    print $row->field;

    $row->field('new data');

    $row->update;

    my $rows = all_rows("table", {field => "some data"});

    print $rows->[0]->field;

=head1 DESCRIPTION

Makes SQL queries from Perl data structures. It uses L<SQL::Abstract> module to 
parse "where" and "order by" structures. It also supports "group by", "having", 
"limit", "offset" and mapping function. To make actual queries subclass of 
L<DBIx::Connector> is used. This class and its singleton connector object can be
pluggable. 

=head2 connect($data_source, $username, $auth)

This method connects to database or returns already connected connector object.
For every table in database there's one corresponding class in DBC:: namespaece 
in CamelCase style after successful connect created. E.g. DBC::ClientData is 
created for table "client_data".

=head2 one_row($table, $abstract_where, $order_by, $limit, $offset)

Selects one row from given table and returns its object. $table can be a simple 
table name or returning data query expression. In last case DBQ:: namespace is 
used to name class of row object of such a query.

There are some named paramters can be used together with positional paramaters:

=over

=item -group_by

Generates "GROUP BY" SQL-clause

 my $row1 = one_row("table", -group_by => "field");

Generates and executes "select * from table group by field" SQL-statement. 
 
 my $row2 = one_row("table", -group_by => [qw|field field2|]);
 
Generates and executes "select * from table group by field, field2" SQL-statement.
Returns one row object.

=item -having

Adds "HAVING" conditions to "GROUP BY"
 
 my $row1 = one_row("table", -group_by => "field", -having => {"length(field)" => {">", 5} });

=item -order_by

Generates "ORDER BY" SQL-clause as in L<SQL::Abstract>.

=item -where

Generates "WHERE" SQL-clause as in L<SQL::Abstract>. If $abstract_where is just a scalar
then it is supposed to be a primary key value.

=item -limit

=item -offset

Generates "LIMIT $X OFFSET $Y" SQL-clause.

=back

=head2 all_rows($table, $abstract_where, $order_by, $limit, $offset)

This is just like previous C<one_row> but returns array of row objects. 
It has one more "floating" parameter: you can specify CODE reference in any 
place and it will be used as "mapping function".

    my $rows =  all_rows("table", 
                     { date => {'>=', \"now() - interval '1 hour'"}, 
                     sub {$_->filter_timestamp; $_->data});

This anonymous function is called for every row clearing timestamps from microseconds part 
and converting every row object into anonymous hash.

=head2 new_row("table", column => $value, column2 => $value2, ...)

Inserts new row into table. Returns row object with set primary columns and passed in 
C<new_row> subroutine. If you need to set all columns from table then:

    my $row = new_row("table", column => $value);
    $row->fetch;

=head1 Row object methods

=head2 new

=head2 set

=head2 data

=head2 update

=head2 delete

=head2 filter_timestamp

=head2 fetch

=head2 accessors

=head2 Syntax sugar

=head3 referenced table

=head3 referenced by table

=cut
